\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{%
  colorlinks=false,
  urlbordercolor=red
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Scalable and Cloud programming - Co-Purchase-Analysis Technical Report}

\author{
\IEEEauthorblockN{1\textsuperscript{st} Michele Dinelli}
\IEEEauthorblockA{\textit{dept. of Computer Science and Engineering, University of Bologna}}
}

\maketitle

\begin{abstract}
This document is the technical report for the scalable and cloud programming project developed for the university course held in Bologna (a.y 24/25). Source code is available online as a \href{https://github.com/micheledinelli/scalable-cloud-programming}{GitHub repository}.
\end{abstract}

\begin{IEEEkeywords}
cloud programming, scala, apache spark, google cloud platform, dataproc
\end{IEEEkeywords}

\section{Introduction}
This document is a technical report that describes the implementation and scaling evaluation of a co-purchase-analysis script written in Scala. The system is required to read purchases data from a dataset \cite{dataset} and it must identify co-purchased products by calculating, for each pair of products, the number of orders in which they were purchased together.

\section{Implementation}
The solution used Apache Spark \cite{10.1145/2934664} and runs on distributed nodes using DataProc \cite{dataproc}. Versions used are Scala 2.3.15 and Spark 3.5.5.

\section{Analytical Metrics}

\subsection{Speedup}
We define $T(n)$ as the execution time of a parallel program with $n$ nodes. The speedup $S(n)$ is defined by the formula
\begin{equation}
S(n)= \frac{T(1)}{T(n)}
\end{equation}
Ideally, the program with $n$ nodes requires $1/n$ the time of the program with 1 node. $S(n) = n$ is a linear speedup but in practice it's sublinear $S(n) \leq n$. This limitation is captured by Amdahl's Law \cite{10.1145/1465482.1465560}, which states that if a task consists of a fraction $f$ hat is inherently sequential (i.e., cannot be parallelized), and the remaining fraction $1-f$ can be sped up by a factor of $P$ then the maximum achievable speedup is
\begin{equation}
\frac{1}{f + \frac{1-f}{P}}\label{eq:amdahl} < \frac{1}{f}
\end{equation}
Even if we could infinitely speed up the parallelizable part (i.e., $P \rightarrow \infty$), the overall speedup would still be limited by the sequential portion $f$.

\subsection{Scaling Efficiency}
To evaluate the impact of Amdahl's law \eqref{eq:amdahl} on a distributed system we introduce Strong Scaling Efficiency (SSE) and Weak Scaling Efficiency (WSE).

\subsubsection{SSE} measures how increasing the number of nodes impacts the speedup while keeping the total amount of work fixed.
\begin{equation}
    SSE(n) = \frac{S(n)}{n} = \frac{T(1)}{n T(n)}
\end{equation}
The total amount of work remains constant, while the amount of work for each processor decreases as $n$ increases. SSE is limited by the constant $\frac{1}{f}$ so it tends to zero.
\begin{equation}
    \lim_{n\to\infty} SSE(n) = \lim_{n\to\infty} \frac{T(1)}{n T(n)} = \lim_{n\to\infty} \frac{1}{fn} = 0
\end{equation}

\subsubsection{WSE} measures how productively a program uses added resources and is defined by
\begin{equation}
    WSE(n) = \frac{T_1}{T_n}
\end{equation}
Where $T_i$ is time required to complete $i$ work unit/s with $i$ node/s. WSE increases the number of nodes $n$ keeping the per-node work fixed as the total amount of work grows as $n$ increases.

\section{Results}

\subsection{Figures and Tables}
\paragraph{Positioning Figures and Tables} Place figures and tables at the top and
bottom of columns. Avoid placing them in the middle of columns. Large
figures and tables may span across both columns. Figure captions should be
below the figures; table heads should appear above the tables. Insert
figures and tables after they are cited in the text. Use the abbreviation
``Fig.~\ref{fig}'', even at the beginning of a sentence.

\begin{table}[htbp]
\caption{Table Type Styles}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
\cline{2-4}
\textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}& \textbf{\textit{Subhead}} \\
\hline
copy& More table copy$^{\mathrm{a}}$& &  \\
\hline
\multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
\end{tabular}
\label{tab1}
\end{center}
\end{table}

\begin{figure}[htbp]
\centerline{\includegraphics{fig1.png}}
\caption{Example of a figure caption.}
\label{fig}
\end{figure}

Figure Labels: Use 8 point Times New Roman for Figure labels. Use words
rather than symbols or abbreviations when writing Figure axis labels to
avoid confusing the reader. As an example, write the quantity
``Magnetization'', or ``Magnetization, M'', not just ``M''. If including
units in the label, present them within parentheses. Do not label axes only
with units. In the example, write ``Magnetization (A/m)'' or ``Magnetization
\{A[m(1)]\}'', not just ``A/m''. Do not label axes with a ratio of
quantities and units. For example, write ``Temperature (K)'', not
``Temperature/K''.

% \section*{Acknowledgment}

% The preferred spelling of the word ``acknowledgment'' in America is without
% an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B.
% G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor
% acknowledgments in the unnumbered footnote on the first page.


\bibliographystyle{IEEEtran}
\bibliography{bib}

\end{document}
